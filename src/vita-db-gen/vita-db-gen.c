#include <dirent.h>
#include <stdio.h>
#include <stdlib.h>
#include <yaml.h>

#include "vita-export.h"
#include "vita-import.h"
#include "utils/yamlemitter.h"

static void show_usage(void)
{
	fprintf(stderr, "usage: vita-db-gen dir1 [dir2...] output\n"
					"\tdir: paths to the directories containing the import files\n"
					"\toutput: path to write the import yaml generated by this tool\n");
}

char* hextostr(int x){
	static char buf[20];
	sprintf(buf,"0x%08X",x);
	return buf;
}

char* booltostr(int x){
	return x ? "true" : "false";
}

int pack_import_symbols(yaml_emitter_t * emitter, yaml_event_t *event, vita_imports_stub_t **symbols, size_t symbol_n)
{

	if(!yamlemitter_mapping_start(emitter, event))
		return 0;
		
	for (int i = 0; i < symbol_n; ++i)
	{		

		if(!yamlemitter_key_value(emitter, event, symbols[i]->name, hextostr(symbols[i]->NID)))
			return 0;
			
	}
	
	yaml_mapping_end_event_initialize(event);
	if (!yaml_emitter_emit(emitter, event))
		return 0;
	
	return -1;
	
}

int compar_modules(const void *p1, const void *p2)
{
    return strcmp((*(vita_imports_module_t **)p1)->name, (*(vita_imports_module_t **)p2)->name);
}

int compar_libs(const void *p1, const void *p2)
{
    return strcmp((*(vita_imports_lib_t **)p1)->name, (*(vita_imports_lib_t **)p2)->name);
}

vita_imports_t *load_imports(char **dirpaths, int dircount)
{
    vita_imports_t *imports, *import;
    char filepath[0x200];
    char modulename[0x80];
    struct dirent *entry;

    imports = vita_imports_new(0);

    for (int i = 0; i < dircount; i++)
    {
        const char *dirpath = dirpaths[i];
        DIR *dir = opendir(dirpath);
        if (dir == NULL)
        {
            fprintf(stderr, "Error: could not open %s\n", dirpath);
            return NULL;
        }

        while ((entry = readdir(dir)) != NULL)
        {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;

            snprintf(filepath, 0x1FF, "%s/%s", dirpath, entry->d_name);
            import = vita_imports_load(filepath, 1);
            if (import == NULL)
            {
                closedir(dir);
                return NULL;
            }

            for (int j = 0; j < import->n_modules; j++)
            {
                snprintf(modulename, 0x7F, "%s%s", import->modules[j]->name, import->postfix);
                free(import->modules[j]->name);
                import->modules[j]->name = strdup(modulename);
                qsort(import->modules[j]->libs, import->modules[j]->n_libs, sizeof(vita_imports_lib_t *), compar_libs);
            }

            imports->modules = realloc(imports->modules, (imports->n_modules + import->n_modules) * sizeof(vita_imports_module_t *));
            memcpy(&imports->modules[imports->n_modules], import->modules, import->n_modules * sizeof(vita_imports_module_t *));
            imports->n_modules += import->n_modules;

            import->n_modules = 0;
            free(import->modules);
            vita_imports_free(import);
        }
        closedir(dir);
    }

    return imports;
}

int main(int argc, char *argv[])
{
	if (argc < 3)
	{
		show_usage();
		return EXIT_FAILURE;
	}

    char **dir = &argv[1];
    const char *output = argv[argc - 1];

    // load our imports
    vita_imports_t *imports = load_imports(dir, argc - 2);
	
	if (!imports)
		return EXIT_FAILURE;

    // sort the modules
    qsort(imports->modules, imports->n_modules, sizeof(vita_imports_module_t *), compar_modules);

    yaml_emitter_t emitter;
	yaml_event_t event;

	/* Create the Emitter object. */
	yaml_emitter_initialize(&emitter);
	
	FILE *fp = fopen(output, "w");

	if (!fp)
	{
		// TODO: handle this
		fprintf(stderr, "could not open '%s' for writing\n", output);
		return EXIT_FAILURE;
	}

	yaml_emitter_set_output_file(&emitter, fp);

	/* Create and emit the STREAM-START event. */
	if(!yamlemitter_stream_start(&emitter, &event))
		goto error;
		
	if(!yamlemitter_document_start(&emitter, &event))
		goto error;
		
	if(!yamlemitter_mapping_start(&emitter, &event))
		goto error;

    if(!yamlemitter_key(&emitter, &event,"modules"))
		goto error;
		
	if(!yamlemitter_mapping_start(&emitter, &event))
		goto error;
			
    for (int n = 0; n < imports->n_modules; n++)
    {
        if (!yamlemitter_key(&emitter, &event, imports->modules[n]->name))
            goto error;

        if (!yamlemitter_mapping_start(&emitter, &event))
            goto error;

        if (!yamlemitter_key_value(&emitter, &event, "nid", hextostr(imports->modules[n]->NID)))
            goto error;

        if (!yamlemitter_key(&emitter, &event, "libraries"))
            goto error;

        if (!yamlemitter_mapping_start(&emitter, &event))
            goto error;

        for (int i = 0; i < imports->modules[n]->n_libs; ++i)
        {
            vita_imports_lib_t *lib = imports->modules[n]->libs[i];

            if (!yamlemitter_key(&emitter, &event, lib->name))
                goto error;

            if (!yamlemitter_mapping_start(&emitter, &event))
                goto error;

            if (!yamlemitter_key_value(&emitter, &event, "kernel", booltostr(lib->is_kernel)))
                goto error;

            if (!yamlemitter_key_value(&emitter, &event, "nid", hextostr(lib->NID)))
                goto error;

            if (lib->n_functions)
            {

                if (!yamlemitter_key(&emitter, &event, "functions"))
                    goto error;

                if (!pack_import_symbols(&emitter, &event, lib->functions, lib->n_functions))
                    goto error;
            }

            if (lib->n_variables)
            {

                if (!yamlemitter_key(&emitter, &event, "variables"))
                    goto error;

                if (!pack_import_symbols(&emitter, &event, lib->variables, lib->n_variables))
                    goto error;
            }

            yaml_mapping_end_event_initialize(&event);
            if (!yaml_emitter_emit(&emitter, &event))
                goto error;
        }

        if (!yamlemitter_mapping_end(&emitter, &event))
            goto error;

        if (!yamlemitter_mapping_end(&emitter, &event))
            goto error;
    }

	if(!yamlemitter_mapping_end(&emitter, &event))
		goto error;
	
	if(!yamlemitter_mapping_end(&emitter, &event))
		goto error;

	if(!yamlemitter_document_end(&emitter, &event))
		goto error;
		
	if(!yamlemitter_stream_end(&emitter, &event))
		goto error;

	/* On error. */
error:
	fclose(fp);
	/* Destroy the Emitter object. */
	yaml_emitter_delete(&emitter);
	/* Free imports */
	vita_imports_free(imports);

	return 0;
}
